'use strict';

// Some hot configs need to be be available when common/ is required
var HOT = exports.hot = require('../config/hot').hot;

var _ = require('underscore'),
	async = require('async'),
	common = require('../common'),
	config = require('../config'),
	crypto = require('crypto'),
	fs = require('fs'),
	hooks = require('../util/hooks'),
	lang = require('../lang'),
	options = require('../common/options'),
	path = require('path'),
	vm = require('vm');

_.templateSettings = {
	interpolate: /\{\{(.+?)}}/g
};

exports.emitter = new (require('events').EventEmitter);

exports.dbCache = {
	OPs: {},
	opTags: {},
	threadSubs: {},
	YAKUMAN: 0,
	funThread: 0,
	addresses: {},
	ranges: {}
};

var RES = exports.resources = {};
exports.clientHotConfig = {};
exports.clientConfigHash = '';
exports.clients = {};
exports.clientsByIP = {};

var clientConfig = exports.clientConfig = _.pick(config,
	'IP_MNEMONIC',
	'USE_WEBSOCKETS',
	'SOCKET_PATH',
	'DEBUG',
	'READ_ONLY',
	'API_URL',
	'IP_TAGGING',
	'RADIO',
	'PYU',
	'BOARDS',
	'LANGS',
	'DEFAULT_LANG',
	'READ_ONLY_BOARDS',
	'WEBM',
	'UPLOAD_URL',
	'MEDIA_URL',
	'THUMB_DIMENSIONS',
	'PINKY_DIMENSIONS',
	'SPOILER_IMAGES',
	'IMAGE_HATS',
	'ASSETS_DIR',
	'BANNERS',
	'RECAPTCHA_PUBLIC_KEY'
);

function reload_hot_config(cb) {
	fs.readFile('./config/hot.js', 'UTF-8', function (err, js) {
		if (err)
			cb(err);
		var hot = {};
		try {
			vm.runInNewContext(js, hot);
		}
		catch (e) {
			return cb(e);
		}
		if (!hot || !hot.hot)
			return cb('Bad hot config.');

		// Overwrite the original object just in case
		for (let key in HOT) {
			delete HOT[key];
		}
		_.extend(HOT, hot.hot);

		// Pass some of the config variables to the client
		var clientHot = exports.clientHotConfig = _.pick(HOT,
			'ILLYA_DANCE',
			'EIGHT_BALL',
			'THREADS_PER_PAGE',
			'ABBREVIATED_REPLIES',
			'SUBJECT_MAX_LENGTH',
			'EXCLUDE_REGEXP',
			'ADMIN_ALIAS',
			'MOD_ALIAS',
			'SAGE_ENABLED',
			'THREAD_LAST_N',
			'BOARD_CSS'
		);

		reloadCSS(clientHot, function(err) {
			if (err)
				return cb(err);
			HOT.CLIENT_CONFIG = JSON.stringify(clientConfig);
			HOT.CLIENT_HOT = JSON.stringify(clientHot);
			// Hash the hot configuration
			exports.clientConfigHash = HOT.CLIENT_CONFIG_HASH = crypto
				.createHash('MD5')
				.update(JSON.stringify(clientHot))
				.digest('hex');

			read_exits('exits.txt', function() {
				hooks.trigger('reloadHot', HOT, cb);
			});
		});
	});
}

function reloadModClient(cb) {
	getRevision('mod', function(err, js) {
		if (err)
			return cb(err);
		// Read moderator js file
		fs.readFile(path.join('state', js.mod), 'UTF-8',
			function (err, modSrc) {
				if (err)
					return cb(err);
				RES.modJs = modSrc;
				cb(null);
			}
		);
	});
}

// Read JS bundles and generate MD5 hashes
function hashBundle(name, cb) {
	let stream = fs.createReadStream(`./www/js/${name}.js`),
		hash = crypto.createHash('md5');
	stream.once('error', function(err) {
		cb(err);
	});
	stream.on('data', function(data) {
		hash.update(data);
	});
	stream.once('end', function() {
		HOT[`${name}_hash`] = hash.digest('hex').slice(0, 8);
		cb(null);
	});
}

// Read JSON files in ./state, generated by grunt-rev
function getRevision(name, cb) {
	fs.readFile(path.join('state', name + '.json'), function(err, json) {
		if (err)
			return cb(err);
		var files;
		try {
			files = JSON.parse(json);
		}
		catch(e) {
			return cb(e);
		}
		if (!files)
			return cb('Bad state/' + name + '.json');
		cb(null, files);
	});
}

function reloadCSS(hot, cb) {
	getRevision('css', function(err, files) {
		if (err)
			return cb(err);
		// Only the curfew template is statically assigned a CSS file. The rest
		// are inserted per request in server/render.js
		HOT.CURFEW_CSS = files['curfew.css'];
		// Export to these modules and client
		HOT.css = hot.css = files;
		cb(null);
	});
}

function reload_resources(cb) {
	read_templates(function (err, tmpls) {
		if (err)
			return cb(err);

		_.extend(RES, expand_templates(tmpls));

		hooks.trigger('reloadResources', RES, cb);
	});
}

function read_templates(cb) {
	function read(dir, file) {
		return fs.readFile.bind(fs, path.join(dir, file), 'UTF-8');
	}

	async.parallel({
		index: read('tmpl', 'index.html'),
		login: read('tmpl', 'login.html'),
		curfew: read('tmpl', 'curfew.html'),
		suspension: read('tmpl', 'suspension.html'),
		notFound: read('www', '404.html'),
		serverError: read('www', '50x.html')
	}, cb);
}

function expand_templates(res) {
	var templateVars = _.clone(HOT);
	_.extend(templateVars, config);
	templateVars.NAVTOP = make_navigation_html();

	templateVars.SCHEDULE = build_schedule(templateVars.SCHEDULE);
	templateVars.FAQ = build_FAQ(templateVars.FAQ);
	// Format info banner
	if (templateVars.BANNERINFO)
		templateVars.BANNERINFO = `&nbsp;&nbsp;[${templateVars.BANNERINFO}]`;

	// Insert variables into the templates
	function tmpl(data, vars) {
		var expanded = _.template(data)(vars ||templateVars);
		return {tmpl: expanded.split(/\$[A-Z]+/),
			src: expanded};
	}

	var ex = {
		curfewTmpl: tmpl(res.curfew).tmpl,
		suspensionTmpl: tmpl(res.suspension).tmpl,
		loginTmpl: tmpl(res.login).tmpl,
		notFoundHtml: res.notFound,
		serverErrorHtml: res.serverError
	};

	// Build index templates for each language
	const langs = config.LANGS;
	for (let i = 0, l = langs.length; i < l; i++) {
		let ln = langs[i];
		// Inject the localised variables
		_.extend(templateVars, lang[ln].tmpl);
		// Build localised options panel
		templateVars.options_panel = buildOptions(lang[ln].opts);

		// Inject language pack
		templateVars.lang = _.clone(lang[ln].common);
		_.chain(templateVars.lang).functions().each(function(key) {
			// Functions can not be converted to JSON, so we stringify them
			templateVars.lang[key] = templateVars.lang[key].toString();
		});
		templateVars.lang = JSON.stringify(templateVars.lang);

		let html = tmpl(res.index);
		ex['indexTmpl-' + ln] = html.tmpl;
		ex['indexHash-' + ln] = crypto
			.createHash('md5')
			.update(html.src)
			.digest('hex')
			.slice(0, 8)
	}
	return ex;
}

function build_schedule(schedule){
	const filler = ['drink & fap', 'fap & drink', 'tea & keiki'];
	let table = '<table>';
	for (let i = 0, l = schedule.length; i < l; i += 3) {
		let day = schedule[i],
			plans = schedule[i + 1],
			time = schedule[i + 2];
		// Fill empty slots
		if (!plans)
			plans = filler[Math.floor(Math.random() * filler.length)];
		if (!time)
			time = 'all day';
		table += common.parseHTML
			`<tr>
				<td>
					<b>${day}&nbsp;&nbsp;</b>
				</td>
				<td>${plans}&nbsp;&nbsp;</td>
				<td>${time}</td>
			</tr>`;
	}
	table += '</table>';
	return table;
}

function build_FAQ(faq) {
	if (faq.length <= 0)
		return;
	let list = '<ul>';
	for (let i = 0, l = faq.length; i < l; i++) {
		list += `<li>${faq[i]}</li>`;
	}
	list += '</ul>';
	return list;
}

// Hardcore pornography
function buildOptions(lang) {
	let html = common.parseHTML
		`<div class="bmodal" id="options-panel">
			<ul class="option_tab_sel">`;
	const tabs = lang.tabs;
	// Render tab butts
	for (let i = 0, l = tabs.length; i < l; i++) {
		html += `<li><a data-content="tab-${i}"`;
		// Highlight the first tabButt by default
		if (i === 0)
			html += ' class="tab_sel"';
		html += `>${tabs[i]}</a></li>`;
	}
	html += '</ul><ul class="option_tab_cont">';
	for (let i = 0, l = tabs.length; i < l; i++) {
		let tab = tabs[i];
		let opts = _.filter(options, function(opt) {
			/*
			 * Pick the options for this specific tab. Don't know why we have
			 * undefineds inside the array, but we do.
			 */
			if (!opt || opt.tab != i)
				return false;
			// Option should not be loaded, because of server-side configs
			return !(opt.load !== undefined && !opt.load);
		});
		html += `<li class="tab-${i}`;
		// Show the first tab by default
		if (i === 0)
			html += ' tab_sel';
		html += '">';
		// Render the actual options
		for (let i = 0, l = opts.length; i < l; i++) {
			html += renderOption(opts[i], lang);
		}
		// Append Export and Import links to first tab
		if (i === 0)
			html += renderExportImport(lang);
		html += '</li>';
	}
	html += '</ul></div>';
	return html;
}

function renderOption(opt, lang) {
	let html = '';
	const isShortcut = opt.type == 'shortcut',
		isList = opt.type instanceof Array,
		isCheckbox = opt.type == 'checkbox' || opt.type === undefined,
		isNumber = opt.type == 'number',
		isImage = opt.type == 'image';
	if (isShortcut)
		html += 'Alt+';
	if (!isList) {
		html += '<input';
		if (isCheckbox || isImage)
			html += ` type="${(isCheckbox ? 'checkbox' : 'file')}"`;
		if (isNumber)
			html += ' style="width: 4em;" maxlength="4"';
		else if (isShortcut)
			html += ' maxlength="1"';
	}
	else
		html += '<select';
	// Custom localisation functions
	let title, label;
	if (opt.lang) {
		title = lang[opt.lang][1](opt.id);
		label = lang[opt.lang][0](opt.id);
	}
	else {
		title = lang[opt.id][1];
		label = lang[opt.id][0];
	}
	html += ` id="${opt.id}" title="${title}">`;

	if (isList) {
		const items = opt.type;
		for (let i = 0, l = items.length; i < l; i++) {
			let item = items[i];
			html += `<option value="${item}">${lang[item] || item}</option>`;
		}
		html += '</select>';
	}
	html += `<label for="${opt.id}" title="${title}">${label}</label><br>`;
	return html;
}

function renderExportImport(lang) {
	let html = '<br>';
	const links = ['export', 'import'];
	for (let i = 0, l = links.length; i < l; i++) {
		let id = links[i],
			ln = lang[id];
		html += `<a id="${id}" title="${ln[1]}">${ln[0]}</a> `;
	}
	// Hidden file input for uploading the JSON
	html += common.parseHTML
		`<input type="file"
			style="display: none;"
			id="importSettings"
			name="Import Settings"
		>
		</input>`;
	return html;
}

function reload_hot_resources (cb) {
	async.series([
		reload_hot_config,
		reloadModClient,
		hashBundle.bind(null, 'client'),
		hashBundle.bind(null, 'vendor'),
		reload_resources
	], cb);
}
exports.reload_hot_resources = reload_hot_resources;

function make_navigation_html() {
	if (!HOT.INTER_BOARD_NAVIGATION)
		return '';
	var bits = '<b id="navTop">[';
	// Actual boards
	const BOARDS = config.BOARDS,
		PB = config.PSUEDO_BOARDS;
	for (let i = 0, l = BOARDS.length; i < l; i++) {
		let board = BOARDS[i];
		if (board == config.STAFF_BOARD)
			continue;
		if (i > 0)
			bits += ' / ';
		bits += `<a href="../${board}/" class="history">${board}</a>`;
	}
	// Add custom URLs to board navigation
	for (let i = 0, l = PB.length; i < l; i++) {
		let item = PB[i];
		bits += ` / <a href="${item[1]}">${item[0]}</a>`;
	}
	bits += ']</b>';
	return bits;
}

function read_exits(file, cb) {
	fs.readFile(file, 'UTF-8', function (err, lines) {
		if (err)
			return cb(err);
		let dest = HOT.BANS;
		const split = lines.split(/\n/g);
		for (let i = 0, l = split.length; i < l; i++) {
			const m = split[i].match(/^(?:^#\d)*(\d+\.\d+\.\d+\.\d+)/);
			if (!m)
				return;
			const exit = m[1];
			if (dest.indexOf(exit) < 0)
				dest.push(exit);
		}
		cb(null);
	});
}
