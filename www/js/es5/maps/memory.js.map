{"version":3,"sources":["memory.js"],"names":["System","register","_export","_context","_classCallCheck","instance","Constructor","TypeError","parseSet","set","val","JSON","parse","e","isEmpty","_size","_createClass","memories","Memory","setters","_underscore","size","execute","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","window","addEventListener","_ref","newValue","cached","expiry","_this","this","read","setTimeout","purgeExpired","value","Math","floor","Date","now","localStorage","removeItem","getItem","purgeAll","setItem","stringify","writeAll","limit","expired","push","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","err"],"mappings":"AAAA,YAAaA,QAAOC,UAAU,cAAc,SAASC,EAAQC,GAAyD,QAASC,GAAgBC,EAASC,GAAa,KAAKD,YAAoBC,IAAc,KAAM,IAAIC,WAAU,qCAAuC,QAASC,GAASC,GAAK,GAAIC,KAAO,KAAIA,EAAIC,KAAKC,MAAMH,GAAM,MAAMI,IAAI,MAAOH,GAA5Q,GAAII,GAAQC,EAAMC,EAAaC,EAASC,CAAyO,QAAQC,SAAS,SAASC,GAAaN,EAAQM,EAAYN,QAAQC,EAAMK,EAAYC,OAAQC,QAAQ,WAAWN,EAAa,WAAW,QAASO,GAAiBC,EAAOC,GAAO,IAAI,GAAIC,GAAE,EAAEA,EAAED,EAAME,OAAOD,IAAI,CAAC,GAAIE,GAAWH,EAAMC,EAAGE,GAAWC,WAAWD,EAAWC,aAAY,EAAMD,EAAWE,cAAa,EAAQ,SAAWF,KAAWA,EAAWG,UAAS,GAAKC,OAAOC,eAAeT,EAAOI,EAAWM,IAAIN,IAAc,MAAO,UAAStB,EAAY6B,EAAWC,GAAuI,MAAvHD,IAAWZ,EAAiBjB,EAAY+B,UAAUF,GAAeC,GAAYb,EAAiBjB,EAAY8B,GAAoB9B,MAAkBW,KAAYqB,OAAOC,iBAAiB,UAAU,SAASC,GAAM,GAAIN,GAAIM,EAAKN,IAAQO,EAASD,EAAKC,QAAYP,KAAOjB,KAAUA,EAASiB,GAAKQ,OAAOlC,EAASiC,MAAcvB,EAAO,WAAW,QAASA,GAAOgB,EAAIS,GAAQ,GAAIC,GAAMC,IAAKzC,GAAgByC,KAAK3B,GAAQ2B,KAAKX,IAAIA,EAAIjB,EAASiB,GAAKW,KAAKA,KAAKF,OAAOA,EAAOE,KAAKH,OAAOG,KAAKC,OAAOC,WAAW,WAAW,MAAOH,GAAMI,gBAAiB,KAoGnzC,MApG0zChC,GAAaE,IAASgB,IAAI,MAAMe,MAAM,WAAe,MAAOC,MAAKC,MAAMC,KAAKC,MAAM,QAAUnB,IAAI,WAAWe,MAAM,WAAoBK,aAAaC,WAAWV,KAAKX,QAASA,IAAI,OAAOe,MAAM,WAAgB,GAAIf,GAAIoB,aAAaE,QAAQX,KAAKX,IAAK,OAAIA,GAAuB1B,EAAS0B,SAASA,IAAI,MAAMe,MAAM,SAAaf,GAAK,QAASW,KAAKH,OAAOR,MAASA,IAAI,WAAWe,MAAM,SAAkBxC,GAAK,MAAGK,GAAQL,GAAaoC,KAAKY,eAAYH,cAAaI,QAAQb,KAAKX,IAAIvB,KAAKgD,UAAUlD,OAAUyB,IAAI,QAAQe,MAAM,SAAef,GAAoF,MAA/EW,MAAKH,OAAOG,KAAKC,OAAOD,KAAKH,OAAOR,GAAKW,KAAKQ,MAAMR,KAAKe,SAASf,KAAKH,QAAe3B,EAAM8B,KAAKH,WAAYR,IAAI,OAAOe,MAAM,WAAgB,MAAOlC,GAAM8B,KAAKH,WAAYR,IAAI,eAAee,MAAM,WAAwBJ,KAAKH,OAAOG,KAAKC,MAAO,IAAIO,GAAIR,KAAKQ,MAAMQ,EAAM,MAAMhB,KAAKF,OAAOmB,IAAW,KAAI,GAAI5B,KAAOW,MAAKH,OAAWW,EAAIR,KAAKH,OAAOR,GAAK2B,GAAOC,EAAQC,KAAK7B,EAAO,IAAI4B,EAAQnC,OAAZ,CAA4B,GAAIqC,IAA0B,EAASC,GAAkB,EAAUC,EAAeC,MAAU,KAAI,IAAI,GAoGt0EC,GApG00EC,EAoG10EP,EAAAQ,OAAAC,cAAAP,GAAAI,EAAAC,EAAAG,QAAAC,MAAAT,GAAA,EAAA,CAAA,GAAA9B,GAAAkC,EAAAnB,YAAAJ,MAAAH,OAAAR,IAAA,MAAAwC,GAAAT,GAAA,EAAAC,EAAAQ,EAAA,QAAA,KAAAV,GAAAK,EAAAA,WAAAA,EAAAA,YAAA,QAAA,GAAAJ,EAAA,KAAAC,IAAArB,KAAAe,SAAAf,KAAAH,aAAAxB,KAAAhB,EAAA,UAAAgB","file":"memory.js","sourcesContent":["import {isEmpty, size} from 'underscore'\n\n// All instances of the Memory class\nconst memories = {}\n\n// Listen for storage events and update the stored value for exising memory\n// instances, if the key changes. These only fire, if the write happens in\n// another tab of the same origin.\nwindow.addEventListener('storage', ({key, newValue}) => {\n\tif (key in memories) {\n\t\tmemories[key].cached = parseSet(newValue)\n\t}\n})\n\n// Parse a stringified set\nfunction parseSet(set) {\n\tlet val = {}\n\ttry {\n\t\tval = JSON.parse(set)\n\t}\n\tcatch(e) {}\n\treturn val\n}\n\n// Self-expiring localStorage set manager\nexport default class Memory {\n\tconstructor(key, expiry) {\n\t\tthis.key = key\n\t\tmemories[key] = this\n\t\tthis.expiry = expiry\n\n\t\t// Read the initial value\n\t\tthis.cached = this.read()\n\n\t\t// Purge old entries on start\n\t\tsetTimeout(() => this.purgeExpired(), 5000)\n\t}\n\n\t// Return current time in seconds\n\tnow() {\n\t\treturn Math.floor(Date.now() / 1000)\n\t}\n\n\t// Clear the stored set\n\tpurgeAll() {\n\t\tlocalStorage.removeItem(this.key)\n\t}\n\n\t// Read and parse the stringified set from localStorage\n\tread() {\n\t\tconst key = localStorage.getItem(this.key)\n\t\tif (!key) {\n\t\t\treturn {}\n\t\t}\n\t\treturn parseSet(key)\n\t}\n\n\t// Return, if the given key exists in the set\n\thas(key) {\n\t\treturn !!this.cached[key]\n\t}\n\n\t// Replace the existing set, if any, with the suplied one\n\twriteAll(set) {\n\t\tif (isEmpty(set)) {\n\t\t\treturn this.purgeAll()\n\t\t}\n\t\tlocalStorage.setItem(this.key, JSON.stringify(set))\n\t}\n\n\t// Write a single key to the stored set\n\twrite(key) {\n\t\t// When performing writes, best fetch everything, rather than rely on\n\t\t// events for browser tab cache synchronisation. Browser backround tab\n\t\t// optimisation might fuck us over.\n\t\tthis.cached = this.read()\n\t\tthis.cached[key] = this.now()\n\t\tthis.writeAll(this.cached)\n\t\treturn size(this.cached) // Return number of items\n\t}\n\n\t// Return the current size of the stored Set\n\tsize() {\n\t\treturn size(this.cached)\n\t}\n\n\t// Delete expired entries from set and write to localStorage\n\tpurgeExpired() {\n\t\tthis.cached = this.read()\n\t\tconst now = this.now(),\n\t\t\tlimit = 86400 * this.expiry,\n\t\t\texpired = []\n\t\tfor (let key in this.cached) {\n\t\t\tif (now > this.cached[key] + limit) {\n\t\t\t\texpired.push(key)\n\t\t\t}\n\t\t}\n\t\tif (!expired.length) {\n\t\t\treturn\n\t\t}\n\t\tfor (let key of expired) {\n\t\t\tdelete this.cached[key]\n\t\t}\n\t\tthis.writeAll(this.cached)\n\t}\n}\n"],"sourceRoot":"/source/"}