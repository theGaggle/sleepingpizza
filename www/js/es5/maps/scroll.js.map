{"version":3,"sources":["scroll.js"],"names":["System","register","_export","_context","cacheState","lockIndicator","document","query","isThread","state","posts","get","checkBottom","height","body","scrollHeight","window","innerHeight","atBottom","scrollY","style","visibility","elExists","el","contains","topDistance","skipCheck","_el$getBoundingClient","getBoundingClientRect","top","referenceDistance","referenceEl","bounds","_arr","_i","length","selector","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","$threads","queryAll","Symbol","iterator","next","done","value","err","aboveBanner","test","location","hash","anchor","scrollTo","$banner","Backbone","options","events","setters","_main","execute","followDOM","func","previous","ret","hidden","delta","scrollBy","page","on","addEventListener","reply","onload"],"mappings":"AAAA,YAAaA,QAAOC,UAAU,QAAQ,SAASC,EAAQC,GAAyG,QAASC,KAAaC,EAAcC,SAASC,MAAM,SAASC,IAAWC,EAAMC,MAAMC,IAAI,UAAW,QAASC,KAAc,GAAIC,GAAOP,SAASQ,KAAKC,aAAaC,OAAOC,WAAYC,GAASL,GAAQG,OAAOG,QAAWd,IAAeA,EAAce,MAAMC,WAAWH,EAAS,UAAU,UAAW,QAASI,GAASC,GAAI,MAAOA,IAAIjB,SAASkB,SAASD,GAAK,QAASE,GAAYF,EAAGG,GAAW,GAAIC,GAAsBJ,EAAGK,wBAA4BC,EAAIF,EAAsBE,GAAI,OAAGH,IAAWG,GAAK,GAAGA,EAAIb,OAAOC,YAAoBY,EAAY,KAAM,QAASC,KAAoB,GAAGR,EAASS,GAAa,CAAC,GAAIC,GAAOP,EAAYM,EAAa,IAAY,OAATC,EAAe,MAAOA,GAAkD,IAAI,GAAzCC,IAAM,UAAU,UAAU,WAAmBC,EAAG,EAAEA,EAAGD,EAAKE,OAAOD,IAsGn0B,CAAnD,GAAIE,GAAAH,EAAAC,GAA+CG,GAAA,EAAAC,GAAA,EAAAC,EAAAC,MAAA,KACvD,IAAA,GAAeC,GAAfC,EAAeC,EAASC,SAASR,GAAlBS,OAAAC,cAAfT,GAAAI,EAAAC,EAAAK,QAAAC,MAAAX,GAAA,EAA4C,CAAA,GAAnCd,GAAAkB,EAAAQ,MACFjB,EAASP,EAAYF,EADgB,IAE5B,OAAXS,EAAiB,MACpBD,GAAcR,EACPS,GAJT,MAAAkB,GAAAZ,GAAA,EAAAC,EAAAW,EAAA,QAAA,KAAAb,GAAAK,EAAAA,WAAAA,EAAAA,YAAA,QAAA,GAAAJ,EAAA,KAAAC,MADuD,QAAAY,KAAA,GAAA,UAAAC,KAAAC,SAAAC,MAAA,CAAA,GAAAC,GAAAjD,SAAAC,MAAA8C,SAAAC,KAAAC,IAAAvC,OAAAwC,SAAA,EAAA/B,EAAA8B,GAAAE,EAAA5C,SAtGQ,GAAI6C,GAASC,EAAQlD,EAAMkC,EAASc,EAAQG,EAAO1C,EAASb,EAAcG,EAASuB,CAsG3F,QAAA8B,SAAA,SAAAC,GAAAJ,EAAAI,EAAAJ,SAAAC,EAAAG,EAAAH,QAAAlD,EAAAqD,EAAArD,MAAAkC,EAAAmB,EAAAnB,SAAAc,EAAAK,EAAAL,QAAAG,EAAAE,EAAAF,SAAAG,QAAA,WAAA,QAAAC,GAAAC,GAAA,GAAAC,GAAApC,IAAAqC,EAAAF,GAAA,KAAA/C,GAAAZ,SAAA8D,SAAAT,EAAAhD,IAAA,cAAA,CAAA,IAAAW,EAAAS,GAAA,MAAAoC,EAAA,IAAAE,GAAA5C,EAAAM,GAAA,GAAAmC,CAAAG,IAAArD,OAAAsD,SAAA,EAAAD,OAAArD,QAAAwC,SAAA,EAAAlD,SAAAQ,KAAAC,aAAA,OAAAoD,GAAAjD,EAAAsB,OAAAnC,EAAAmC,OAAAhC,EAAAgC,OAAA/B,EAAA8D,KAAAC,GAAA,SAAApE,GAAAA,IAAAQ,IAAAN,SAAAmE,iBAAA,SAAA7D,GAAAmB,EAAAS,OAAAtC,EAAA,YAAA8D,GAAAJ,EAAAc,MAAA,qBAAAvB,GAAAnC,OAAA2D,OAAAxB","file":"scroll.js","sourcesContent":["/*\n * Various page scrolling logic\n */\n\nimport {Backbone, options, state, $threads, $banner, events} from 'main'\n\nlet atBottom, lockIndicator, isThread\n\n/**\n * Write the current state to variables\n */\nfunction cacheState() {\n\tlockIndicator = document.query('#lock')\n\tisThread = !!state.posts.get('thread')\n}\n\n// Recache state on page change\nstate.page.on('change', cacheState)\ncacheState()\n\n/**\n * Set the scroll lock position to a post or to the bottom of the document\n */\nfunction checkBottom() {\n\tconst height = document.body.scrollHeight - window.innerHeight\n\tatBottom = height <= window.scrollY\n\tif (lockIndicator) {\n\t\tlockIndicator.style.visibility = atBottom ? 'visible' : 'hidden'\n\t}\n}\n\ncheckBottom()\ndocument.addEventListener('scroll', checkBottom)\n\n// Cache previous reference element to minimize DOM lookup\nlet referenceEl\n\n/**\n * Lock position to the bottom of a thread or keep the viewport from bumping\n * on out of sight DOM mutation.\n * @param {function} func\n * @returns {*}\n */\nexport function followDOM(func) {\n\tconst previous = referenceDistance(),\n\t\tret = func()\n\n\t// Prevent scrolling with new posts, if page isn't visible\n\tif (atBottom && (!document.hidden || options.get('alwaysLock'))) {\n\t\twindow.scrollTo(0,  document.body.scrollHeight)\n\t} else {\n\t\t// Element was removed or something\n\t\tif (!elExists(referenceEl)) {\n\t\t\treturn ret\n\t\t}\n\n\t\t// Only compensate, if the height increased above the viewport\n\t\tconst delta = topDistance(referenceEl, true) - previous\n\t\tif (delta) {\n\t\t\twindow.scrollBy(0, delta)\n\t\t}\n\t}\n\treturn ret\n}\n\n/**\n * Check if element reference exists and is in the DOM\n * @param {Element} el\n */\nfunction elExists(el) {\n\treturn el && document.contains(el)\n}\n\n/**\n * Return element position dimentions against the viewport, if the element\n * is withing the viewport\n * @param {Element} el\n * @param {bool} skipCheck\n * @returns {(Number|null)}\n */\nfunction topDistance(el, skipCheck) {\n\tconst {top} = el.getBoundingClientRect()\n\tif (skipCheck || (top >= 0 && top < window.innerHeight)) {\n\t\treturn top\n\t}\n\treturn null\n}\n\n/**\n * Returns distance of viewport to with current reference element\n * @returns {(Number|null)}\n */\nfunction referenceDistance() {\n\tif (elExists(referenceEl)) {\n\t\tconst bounds = topDistance(referenceEl)\n\t\tif (bounds !== null) {\n\t\t\treturn bounds\n\t\t}\n\t}\n\n\t// Find new reference element (first inside viewport). Account for empty\n\t// threads and boards with no artciles or sections.\n\tfor (let selector of ['article', 'section', 'threads']) {\n\t\tfor (let el of $threads.queryAll(selector)) {\n\t\t\tconst bounds = topDistance(el)\n\t\t\tif (bounds !== null) {\n\t\t\t\treferenceEl = el\n\t\t\t\treturn bounds\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Account for banner height, when scrolling to an anchor\n */\nfunction aboveBanner (){\n\tif (!/^#p\\d+$/.test(location.hash)) {\n\t\treturn\n\t}\n\tconst anchor = document.query(location.hash)\n\tif (!anchor) {\n\t\treturn\n\t}\n\twindow.scrollTo(0, topDistance(anchor) - $banner.height)\n}\nevents.reply('scroll:aboveBanner', aboveBanner)\nwindow.onload = aboveBanner\n"],"sourceRoot":"/source/"}