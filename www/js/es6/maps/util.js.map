{"version":3,"sources":["util.js"],"names":[],"mappings":"mwEA+KiB,EAAI,CAAJ,yBAAI,CAAJ","file":"util.js","sourcesContent":["/*\n Client-side helper functions\n */\n\nimport {config} from './main'\nimport {escape} from 'underscore'\n\n// Make spoiler tags toggleable on mobile\nexport function touchable_spoiler_tag(del) {\n\tdel.innerHTML = '<del onclick=\"void(0)\">'\n}\n\n// Retrieve post number of post element\nexport function getNum(el) {\n\tif (!el) {\n\t\treturn 0\n\t}\n\treturn parseInt(el.getAttribute('id').slice(1), 10)\n}\n\n// Retrieve post number of closest parent post\nexport function getID(el) {\n\tif (!el) {\n\t\treturn 0\n\t}\n\treturn getNum(el.closest('article, section'))\n}\n\n\n// Parse HTML string to node array\nexport function parseEls(string) {\n\tconst el = document.createElement('div')\n\tel.innerHTML = string\n\tconst children = el.childNodes\n\treturn Array.from(children)\n}\n\n// Parse HTML string to single Element\nexport function parseEl(string) {\n\tconst el = document.createElement('div')\n\tel.innerHTML = string\n\treturn el.firstChild\n}\n\n// Add an event listener that filters targets according to a CSS selector\nexport function listener(el, type, selector, handler) {\n\tel.addEventListener(type, event => {\n\t\tif (event.target.matches(selector)) {\n\t\t\thandler(event)\n\t\t}\n\t})\n}\n\n// Add event listener to element, that will only be executed once\nexport function once(el, type, handler) {\n\tel.addEventListener(type, event => {\n\t\thandler(event)\n\t\tel.removeEventListener(type, handler)\n\t})\n}\n\n// Return width of element with padding and margin\nexport function outerWidth(el) {\n\tconst style =  getComputedStyle(el),\n\t\tprops = ['marginLeft', 'marginRight', 'paddingLeft','paddingRight']\n\tlet width = 0\n\tfor (let prop of props) {\n\t\twidth += parseInt(style[prop]);\n\t}\n\treturn width\n}\n\n\n// Confirms email is saging\nexport function isSage(email) {\n\tif (email) {\n\t\treturn email.trim() === 'sage'\n\t}\n\treturn false\n}\n\n// TODO: Refactor server time syncronisation\n// let cachedOffset;\n// export function serverTime() :number {\n// \tconst d = Date.now();\n// \tif (imports.isNode)\n// \t\treturn d;\n//\n// \t// The offset is intialised as 0, so there is something to return, until\n// \t// we get a propper number from the server.\n// \tif (!cachedOffset)\n// \t\tcachedOffset = imports.main.request('time:offset');\n// \treturn d + cachedOffset;\n// }\n\n// Pick the next spoiler from one of the available spoilers\nexport function pick_spoiler(metaIndex) {\n\tconst imgs = config.SPOILER_IMAGES,\n\t\tn = imgs.length\n\tlet i\n\tif (metaIndex < 0) {\n\t\ti = Math.floor(Math.random() * n)\n\t} else {\n\t\ti = metaIndex % n\n\t}\n\treturn {\n\t\tindex: imgs[i],\n\t\tnext: (i + 1) % n\n\t}\n}\n\nexport const thumbStyles = ['small', 'sharp', 'hide']\n\n// Pad an integer with a leading zero, if below 10\nexport function pad(n) {\n\treturn (n < 10 ? '0' : '') + n\n}\n\n// Various UI-related links wrapped in []\n// export function action_link_html(href , name, id, cls) {\n// \treturn parseHTML\n// \t\t`<span class=\"act\">\n// \t\t\t<a href=\"${href}\"\n// \t\t\t\t${id && ` id=\"${id}\"`}\n// \t\t\t\t${cls && ` class=\"${cls}\"`}\n// \t\t\t>\n// \t\t\t\t${name}\n// \t\t\t</a>\n// \t\t</span>`;\n// }\n\n// Confirm last N posts to view setting matches bounds\nexport function resonableLastN(n) {\n\treturn Number.isInteger(n) && n <= 500\n}\n\n// export function parse_name(name) {\n// \tvar tripcode = '', secure = '';\n// \tvar hash = name.indexOf('#');\n// \tif (hash >= 0) {\n// \t\ttripcode = name.substr(hash + 1);\n// \t\tname = name.substr(0, hash);\n// \t\thash = tripcode.indexOf('#');\n// \t\tif (hash >= 0) {\n// \t\t\tsecure = escape(tripcode.substr(hash + 1));\n// \t\t\ttripcode = tripcode.substr(0, hash);\n// \t\t}\n// \t\ttripcode = escape(tripcode);\n// \t}\n// \tname = name.trim().replace(imports.hotConfig.EXCLUDE_REGEXP, '');\n// \treturn [\n// \t\tname.substr(0, 100), tripcode.substr(0, 128),\n// \t\tsecure.substr(0, 128)\n// \t];\n// }\n\n// Generate a random alphannumeric string of lower and upper case hexadecimal\n// characters\nexport function randomID(len) {\n\tlet id = ''\n\tfor (let i = 0; i < len; i++) {\n\t\tlet char = (Math.random() * 36).toString(36)[0]\n\t\tif (Math.random() < 0.5) {\n\t\t\tchar = char.toUpperCase()\n\t\t}\n\t\tid += char\n\t}\n\treturn id\n}\n\n// Template string tag function for HTML. Strips indentation and trailing\n// newlines. Based on https://gist.github.com/zenparsing/5dffde82d9acef19e43c\nexport function parseHTML(callSite, ...args) {\n\tlet output = callSite[0]\n\tfor (let i = 1; i <= args.length; i++) {\n\t\toutput += args[i - 1] + callSite[i]\n\t}\n\n\t// Strip indentation and remove empty lines from HTML string\n\treturn output.replace(/\\s*\\n\\s*/g, '')\n}\n\n\n// Generate an HTML element attribute list\nexport function parseAttributes(attrs) {\n\tlet html = ''\n\tfor (let key in attrs) {\n\t\thtml += ' '\n\t\tconst val = attrs[key]\n\t\tif (val === true) {\n\t\t\thtml += key\n\t\t} else if (val || val === 0) {\n\t\t\thtml += `${key}=\"${val}\"`\n\t\t}\n\t}\n\treturn html\n}\n\n// Makes a ', ' seperated list out of on array of strings\nexport function commaList(items) {\n\tlet html = ''\n\tfor (let item of items) {\n\t\tif (html) {\n\t\t\thtml += ', '\n\t\t}\n\t\thtml += item\n\t}\n\treturn html\n}\n\n// Acertains client has the proper authorisation to perfrom task. This is only\n// for rendering. The same validation is performed server-side.\nexport function checkAuth(action) {\n\tconst cls = config.staff.classes[main.ident && main.ident.auth]\n\treturn cls && !!cls.rights[action]\n}\n"],"sourceRoot":"/source/"}